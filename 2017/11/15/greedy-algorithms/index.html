<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="English">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="What does greedy means?Always pick short term best decision.It is easy to invent greedy algorithm, but how to prove they work well is a challenge. First Problem : Interval SchedulingWe have a set of r">
<meta property="og:type" content="article">
<meta property="og:title" content="greedy_algorithms">
<meta property="og:url" content="http://yoursite.com/2017/11/15/greedy-algorithms/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="What does greedy means?Always pick short term best decision.It is easy to invent greedy algorithm, but how to prove they work well is a challenge. First Problem : Interval SchedulingWe have a set of r">
<meta property="og:locale" content="English">
<meta property="og:image" content="http://yoursite.com/images/interval.jpg">
<meta property="og:image" content="http://yoursite.com/images/interval2.jpg">
<meta property="og:updated_time" content="2017-11-20T20:18:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="greedy_algorithms">
<meta name="twitter:description" content="What does greedy means?Always pick short term best decision.It is easy to invent greedy algorithm, but how to prove they work well is a challenge. First Problem : Interval SchedulingWe have a set of r">
<meta name="twitter:image" content="http://yoursite.com/images/interval.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/15/greedy-algorithms/"/>





  <title>greedy_algorithms | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/greedy-algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue Guo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">greedy_algorithms</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-15T16:59:55-05:00">
                2017-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>What does greedy means?<br>Always pick short term best decision.<br>It is easy to invent greedy algorithm, but how to prove they work well is a challenge.</p>
<h3 id="First-Problem-Interval-Scheduling"><a href="#First-Problem-Interval-Scheduling" class="headerlink" title="First Problem : Interval Scheduling"></a>First Problem : Interval Scheduling</h3><p>We have a set of requests: {1,2,….,n}, and each of them has start-time and finish-time, (s1,f1), (s2,f2),…., (sn,fn).<br>Define: The whole set is compatible if no two of them overlap in time.<br>Goal: Accept as large a compatible subset as possible.</p>
<p>Using greedy algorithm:<br>We accept a request i and reject all requests that are not compatible with it. We continue doing this until we run out of request.</p>
<p>The problem is, which rules should we follow to pick up a request in each iteration.<br>We may have several possible ways:</p>
<ol>
<li>pick up the first start request.</li>
<li>pick up the smallest request.</li>
<li>pick up the one has fewest noncompatible request.</li>
<li>pick up the first finish request.</li>
</ol>
<p><img src="/images/interval.jpg" width="60%" height="60%" align="center/"><br>(Using the example from book “Algorithm Design”)</p>
<p>With these three example, we can find that rule 1, rule 2 and rule 3 are all wrong. And we should accept the request that finishes first.<br>Here is the algorithm:</p>
<pre><code>Initialize R with the set of all request, and let A be empty:
WHILE R is not empty:
     Choose a request i that finishes first;
    Add i to A:
    Delete all requests that are not compatible with i;
END WHILE
Return A
</code></pre><p>Think about it, when we choose a request that finishes first, then we can maximize time left to satisfy other requests.<br>Proof:<br>The algorithm gives us subset A{i1, i2,….,ik]<br>if there exists another subset that are larger than k, which is {j1, j2,….,jm}, in which m&gt;k<br>find the first iq != jq, (q&lt;=k), then f(iq)&lt;f(jq), so we can use iq to replace jq …. ik replce jk,<br>Since the jk+1,jk+2….jm are all compatible with jk, the algorithm can not be stop at ik.<br>This is a  contradiction.</p>
<p>Implementation &amp; Running Time:<br>We begin by sorting n request in order of finishing time and labeling them in this order. This take time O(nlogn).<br>Then we always maintain the finish time f of the last accepted job. We then iterate through the intervals in order until reaching the first interval j for which s(j)&gt;=f, then we select j, and update f with f(j). We continue iterations until there is no more request. This part of algorithm takes time O(n).</p>
<h3 id="A-Related-Problem-Scheduling-All-Intervals"><a href="#A-Related-Problem-Scheduling-All-Intervals" class="headerlink" title="A Related Problem: Scheduling All Intervals"></a>A Related Problem: Scheduling All Intervals</h3><p>If we have many resources, which is different from above question(just one), we want to schedule all requests with as few resources as possible.</p>
<p>In any possible solutions, the number of resources must be at least the depth of the set of intervals.<br>Proof: Suppose a set of intervals has depth d, and i1, i2,….id all pass over a common point on the time-line. Then each of theses intervals must be scheduled on a different resource, so the whole instance needs at least d resources.</p>
<p>If we still sort all requests in order of finishing time, we will not have optimal answers.<br>For example,<br><img src="/images/interval2.jpg" width="30%" height="30%" align="center/"></p>
<p>Here is the algorithm:</p>
<pre><code>Sort requests in increasing order of start time i1, i2,...in, breaking ties arbitartily
For j=1,2,3...,n loop:
    if there exits a resource that can accept ij, 
    then choose any such resource
    ELSE Allocate a new resource and accept ij.
END Loop
</code></pre><p> Prove the algorithm uses less than or equal to depth resources.<br> Assume for contradiction, if the algorithm used more than depth resources, means at some time t, there is a request i, which can not be accepted by any resource. For each iq1,…iqd, we have s(iq)<s(i), and="" f(iq)="">s(i). At time t=s(i)+(time -&gt;0), there are at least depth+1 active request, which is contradict to the definition of depth.<br> So since the algorithm gives us less than or equal to depth resources, and the number of resources must be at least the depth of the set of intervals. The algorithm gives us the optimal number of resource needed.</s(i),></p>
<h3 id="Minimun-Spanning-Tree"><a href="#Minimun-Spanning-Tree" class="headerlink" title="Minimun Spanning Tree"></a>Minimun Spanning Tree</h3><p> We have a set of location {v1,v2,…,vn} and we want to build a road to connect all of them and minimize the whole cost.</p>
<p> What is the definition of tree?<br> Look up on Wikipedia, “In mathematics, and more specifically in graph theory, a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any acyclic connected graph is a tree.”</p>
<p> Clearly, our solution to the path defined above must be a tree.<br> Proof: if there exists a cycle, then we can delete a edge on circle. And the graph is still connected, and the remaining cost is cheaper– a contradiction.</p>
<p>Goal: Finding a spanning tree with minimum total cost.<br>We have three ways to get a MST.<br>First, we can greedily adding edges to tree.<br>We sort all edges from E in order of increasing cost. As we move through the edges in this order, we insert each edge e as long as it does not create a cycle when added to the edges we’ve already inserted. This is Kruskal’s Algorithm.</p>
<p>Second is the Reverse Deletion Algorithm.<br>We sort all edges from E in order of decreasing cost. As we move through the edges in this order, we delete each edge e as long as the graph is still connected when delete from the remaining edges. </p>
<p>The third one is called Prim’s Algorithm. It is like Dijkstra’s Algorithm for path. Later, we can compare those two together.</p>
<p>Proof of Kruskal’s Algorithm:<br>Assume all edge weights are distinct (think about why this assumption can be easily eliminated)<br>Claim 1: Let T be a minimum spanning tree, e belongs to E not in T, e has the maximum weight in the fundamental cycle defined by T, e.<br>Proof: Assume for contradiction, if there exists e’ in the fundamental cycle such that the weight e’ &gt; e. Consider T’=T{e’}U{e}, then T’ is still a spanning tree, and the total weight of T’&lt;T. So, contradiction with T is a minimum spanning tree.</p>
<p>Cut Property: Assume that all edge costs are distinct. Let S be any subset of nodes that is neither empty nor equal to all of V, and let edge e=(v,w) be the minimum  cost edge with one end in S and the other in V-S. Then every minimum spanning tree contains the edge e.<br>Proof: Assume for contradiction, if T is a minimum spanning tree and does not contain edge e, then we add e to T, contradict to Claim 1.</p>
<p>Claim 2: Let T be a minimum spanning tree, e belongs to T, e has the minimum weight in the fundamental cut, defined by T, e.<br>Proof: Assume for contradiction, if there exists e’ in the fundamental cut and not belong to T and the weight of e’&lt;e. Consider T’=T{e}U{e’}, then T’ is still a spanning tree, and and the total weight of T’&lt;T. So, contradiction with T is a minimum spanning tree.</p>
<p>Cycle Property: For any cycle C, let e be the most expensive edge in C, then e must not belong to any MST.<br>Proof: Assume for contradiction, if T is a minimum spanning tree and contain edge e, contradict to Claim 2.</p>
<p>With Cut Property, we can easily prove the optimality of both Kruskal’s Algorithm and Prim’s Algorithm. In both algorithm, when we add an edge only it is justified by the Cut Property. With Cycle Property, we can easily prove the optimality of Reverse Algorithm.</p>
<p>In addition, if we combine Cut Property with Cycle Property, any algorithm that builds a MST by repeatedly adding edges when justified by the Cut Property or deleting edges when justified by Cycle Property- in any order- will end up a minimum spanning tree.</p>
<p>Prime’s Algorithm:<br>    S={v1}, T=empty;<br>    For i = 1 to n-1 Do:<br>        Find the cheapest edge e =(u,v), such that u belongs to S, v belongs to V-S,<br>    S=SU{v}, T=TU{e}<br>    Return T<br>Implementation:<br>    Using a priority Queue, namely Q. key=w(neighbor[v],v)<br>    For i = 1 to n-1 Do:<br>    ExtraMin w(neighbor[v],v)<br>    u&lt;-neighbor[v], e &lt;-(u,v)<br>    S&lt;-SU{v}, T&lt;-TU{e}<br>    For all (v,z) belongs to E, z does not in S,<br>        if w(v,z) &lt;w(neighbor[z],z), then update neighbor[z]&lt;-v.</p>
<p>In the loop, each v is extracted, we need to update degree of v’s decrease key. Because since v is added to S, its neighbor;s key can be decreased. The total number of DecreaseKey call is at most 2m. And the total number of ExtraMin call is at most n.<br>With Fibonacci Heap, ExtraMin takes O(logn) time and DecreaseKey only takes O(1) time.<br>So the time complexity of Prim’s algorithm is n*logn+m.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/15/algorithm/" rel="next" title="algorithm- Stable Matching">
                <i class="fa fa-chevron-left"></i> algorithm- Stable Matching
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue Guo</p>
              <p class="site-description motion-element" itemprop="description">Data Science Blog about R</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#First-Problem-Interval-Scheduling"><span class="nav-number">1.</span> <span class="nav-text">First Problem : Interval Scheduling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Related-Problem-Scheduling-All-Intervals"><span class="nav-number">2.</span> <span class="nav-text">A Related Problem: Scheduling All Intervals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minimun-Spanning-Tree"><span class="nav-number">3.</span> <span class="nav-text">Minimun Spanning Tree</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue Guo</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
